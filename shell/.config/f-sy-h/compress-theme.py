#!/usr/bin/env python3
import sys, re, argparse
from collections import defaultdict, OrderedDict

# Matches: ${FAST_HIGHLIGHT_STYLES[key]:=value}
STYLE_RE = re.compile(r"\$\{FAST_HIGHLIGHT_STYLES\[([^\]]+)\]:=([^}]+)\}")

# Matches: typeset ... FAST_THEME_NAME=...
TNAME_TYPES_RE = re.compile(r'^\s*typeset(?:\s+-g)?\s+FAST_THEME_NAME\s*=\s*"?([^"]+)"?')

# Matches: zstyle :plugin:fast-syntax-highlighting theme ...
TNAME_ZSTYLE_RE = re.compile(r'^\s*zstyle\s+:plugin:fast-syntax-highlighting\s+theme\s+"?([^"]+)"?')

def trim(s: str) -> str:
    """Trim whitespace from both ends."""
    return s.strip()

def dequote(s: str) -> str:
    """Remove single/double quotes if present around the string."""
    s = s.strip()
    if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
        return s[1:-1]
    return s

def parse_file(path: str):
    """
    Parse theme file and extract:
    - raw: OrderedDict of key -> style for all entries
    - theme_detected: theme name (if found)
    - matches: number of style matches found
    """
    raw = OrderedDict()
    theme_detected = None
    matches = 0

    with (open(path, 'r', encoding='utf-8') if path != "-" else sys.stdin) as f:
        for line in f:
            # Remove trailing inline comment starting with '#'
            if "#" in line:
                line = line.split("#", 1)[0]
            line = line.strip()
            if not line:
                continue

            # Detect theme name from typeset or zstyle
            m = TNAME_TYPES_RE.search(line)
            if m:
                theme_detected = dequote(m.group(1))
                continue
            m = TNAME_ZSTYLE_RE.search(line)
            if m:
                theme_detected = dequote(m.group(1))
                continue

            # Match style assignment lines
            m = STYLE_RE.search(line)
            if m:
                key = trim(m.group(1))
                val = trim(m.group(2))
                matches += 1
                # Keep the first occurrence (later overridden if keep_last=True)
                if key not in raw:
                    raw[key] = val
                else:
                    pass # Will handle duplicates later if keep_last is set

    return raw, theme_detected, matches

def compress(raw, theme, drop_nones=False, keep_last=False, min_group=2):
    """
    Compress theme data:
    - Optionally keep only the last duplicate entry
    - Group file extensions by style for batch _setstyle loops
    """
    if keep_last:
        # Reverse traversal so the last occurrence wins
        last = OrderedDict()
        for k in reversed(list(raw.keys())):
            last[k] = raw[k]
        raw = OrderedDict(reversed(list(last.items())))

    gen = OrderedDict() # Non-extension theme keys
    ext2style = OrderedDict() # ext -> style

    for k, v in raw.items():
        if drop_nones and v == "none":
            continue
        if k.startswith(f"{theme}file-extensions-"):
            ext = k[len(f"{theme}file-extensions-"):].lower()
            if ext not in ext2style:
                ext2style[ext] = v
            else:
                pass # Ignore duplicates unless keep_last was applied earlier
        elif k.startswith(theme):
            if k not in gen:
                gen[k] = v

    # Group extensions by identical style
    style_groups = defaultdict(list)
    for ext, st in ext2style.items():
        style_groups[st].append(ext)

    # Deduplicate and sort for deterministic output
    for st in style_groups:
        style_groups[st] = sorted(set(style_groups[st]))

    return gen, style_groups

def emit(theme, gen, style_groups, min_group, out):
    """Emit compressed theme as Zsh script."""
    w = out.write
    w("### Generated by compress_theme.py â€” do not hand-edit\n")
    w(f"typeset -g FAST_THEME_NAME={theme}\n\n")
    w("typeset -gA FAST_HIGHLIGHT_STYLES=(\n")
    for k, v in gen.items():
        w(f"  [{k}]='{v}'\n")
    w(")\n\n")
    w('_setstyle(){ local k=$1 v=$2; [[ -n ${FAST_HIGHLIGHT_STYLES[$k]-} ]] || FAST_HIGHLIGHT_STYLES[$k]=$v; }\n\n')
    for style, exts in style_groups.items():
        if len(exts) >= min_group:
            w(f"for ext in {' '.join(exts)}; do _setstyle \"${{FAST_THEME_NAME}}file-extensions-$ext\" '{style}'; done\n")
        else:
            for e in exts:
                w(f"_setstyle \"${{FAST_THEME_NAME}}file-extensions-{e}\" '{style}'\n")
    w("# ðŸ¥Ÿ pie")

def main():
    ap = argparse.ArgumentParser(description="Compress F-Sy-H theme file")
    ap.add_argument("input", help="input theme file (or - for stdin)")
    ap.add_argument("--theme", help="override theme name")
    ap.add_argument("--drop-nones", action="store_true", help="drop entries with style 'none'")
    ap.add_argument("--keep-last", action="store_true", help="last wins on duplicates")
    ap.add_argument("--min-group", type=int, default=2, help="min group size to emit a loop")
    args = ap.parse_args()

    raw, detected, matches = parse_file(args.input)
    theme = args.theme or detected or "neg"
    if matches == 0:
        print("# ERROR: nothing recognized. Expected lines like ${FAST_HIGHLIGHT_STYLES[...]:=...}", file=sys.stderr)
        sys.exit(1)

    gen, style_groups = compress(
        raw, theme,
        drop_nones=args.drop_nones,
        keep_last=args.keep_last,
        min_group=args.min_group
    )
    emit(theme, gen, style_groups, args.min_group, sys.stdout)

if __name__ == "__main__":
    main()
