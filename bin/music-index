#!/usr/bin/env python3
import argparse
import concurrent.futures
import hashlib
import json
import os
import subprocess as sp
import sys
import tempfile
from pathlib import Path

try:
    import orjson  # type: ignore
except Exception:  # pragma: no cover
    orjson = None
import numpy as np
try:
    from annoy import AnnoyIndex  # type: ignore
except Exception as e:
    print("[music-index] Missing python module 'annoy'. Install pythonPackages.annoy", file=sys.stderr)
    raise


AUDIO_EXTS = {".mp3", ".flac", ".wav", ".ogg", ".m4a", ".opus", ".aac", ".wma"}


def read_json_bytes(path: Path) -> dict:
    data = path.read_bytes()
    if orjson:
        return orjson.loads(data)
    return json.loads(data.decode("utf-8"))


def vec_from_essentia(d: dict) -> np.ndarray:
    # Minimal, robust feature vector
    def arr(path, default=()):
        cur = d
        for k in path:
            if not isinstance(cur, dict) or k not in cur:
                return np.asarray(default, dtype=np.float32)
            cur = cur[k]
        return np.asarray(cur, dtype=np.float32)

    parts = [
        arr(["lowlevel", "mfcc", "mean"]),
        arr(["tonal", "hpcp", "mean"]),
        arr(["tonal", "chords_histogram"], default=()),
        np.asarray([float(d.get("rhythm", {}).get("bpm", 0.0))], dtype=np.float32),
    ]
    v = np.concatenate([p for p in parts if p.size > 0], axis=0)
    # L2 normalize for angular distance
    n = float(np.linalg.norm(v))
    return v / (n + 1e-8)


def extract_one(audio_path: Path) -> tuple[Path, np.ndarray] | None:
    try:
        with tempfile.TemporaryDirectory() as td:
            out_json = Path(td) / "feat.json"
            cmd = ["streaming_extractor_music", str(audio_path), str(out_json)]
            sp.run(cmd, check=True, stdout=sp.DEVNULL, stderr=sp.DEVNULL)
            d = read_json_bytes(out_json)
            v = vec_from_essentia(d)
            if v.size == 0:
                return None
            return (audio_path, v)
    except sp.CalledProcessError:
        print(f"[music-index] extractor failed: {audio_path}", file=sys.stderr)
        return None
    except Exception as e:
        print(f"[music-index] error {audio_path}: {e}", file=sys.stderr)
        return None


def walk_audios(root: Path):
    for p in root.rglob("*"):
        if p.is_file() and p.suffix.lower() in AUDIO_EXTS:
            yield p


def main():
    ap = argparse.ArgumentParser(description="Build a similarity index from audio files using Essentia + Annoy")
    ap.add_argument("music_dir", nargs="?", default=os.environ.get("MUSIC_DIR", str(Path.home() / "music")))
    ap.add_argument("--out", default=str(Path.home() / ".cache" / "music-index"), help="output directory for index files")
    ap.add_argument("-j", "--jobs", type=int, default=os.cpu_count() or 4, help="parallel workers")
    ap.add_argument("-n", "--limit", type=int, default=0, help="limit number of files (debug)")
    args = ap.parse_args()

    music_dir = Path(args.music_dir).expanduser().resolve()
    out_dir = Path(args.out).expanduser().resolve()
    out_dir.mkdir(parents=True, exist_ok=True)

    files = list(walk_audios(music_dir))
    if args.limit:
        files = files[: args.limit]
    if not files:
        print(f"[music-index] no audio files under {music_dir}")
        return 1

    print(f"[music-index] extracting features from {len(files)} files with {args.jobs} workers…")

    results: list[tuple[Path, np.ndarray]] = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.jobs) as ex:
        for res in ex.map(extract_one, files):
            if res is not None:
                results.append(res)

    if not results:
        print("[music-index] no features extracted", file=sys.stderr)
        return 2

    dim = results[0][1].shape[0]
    idx = AnnoyIndex(dim, "angular")
    tracks = []
    for i, (path, vec) in enumerate(results):
        idx.add_item(i, vec.tolist())
        tracks.append(str(path))

    print(f"[music-index] building Annoy index (items={len(tracks)}, dim={dim})…")
    idx.build(50)
    idx.save(str(out_dir / "index.ann"))
    (out_dir / "tracks.jsonl").write_text("\n".join(json.dumps({"path": p}) for p in tracks))
    meta = {"dim": dim, "count": len(tracks)}
    (out_dir / "meta.json").write_text(json.dumps(meta))
    print(f"[music-index] wrote {out_dir}/index.ann and tracks.jsonl")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

